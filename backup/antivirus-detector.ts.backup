import { exec } from 'child_process';
import { promisify } from 'util';
import { readFile } from 'fs/promises';
import { AntivirusStatus } from '../../types';
import os from 'os';

const execAsync = promisify(exec);

async function isWSL(): Promise<boolean> {
  try {
    const procVersion = await readFile('/proc/version', 'utf-8');
    return procVersion.toLowerCase().includes('microsoft') || procVersion.toLowerCase().includes('wsl');
  } catch {
    return false;
  }
}

// Verifica se un antivirus Windows è effettivamente in esecuzione controllando i suoi servizi
async function isAntivirusRunning(avName: string): Promise<boolean> {
  const isWsl = await isWSL();
  const scCommand = isWsl ? 'sc.exe' : 'sc';

  // Mappa dei servizi tipici per ogni antivirus
  const serviceMap: { [key: string]: string[] } = {
    'eset': ['ekrn', 'EsetSecurity'],
    'avg': ['AVG Antivirus', 'avgwd', 'AVGSvc'],
    'avast': ['avast! Antivirus', 'AvastSvc', 'aswbidsdriver'],
    'norton': ['Norton Security', 'NortonSecurity'],
    'mcafee': ['McAfee', 'McShield', 'mfemms'],
    'kaspersky': ['AVP', 'KAVFS', 'KAVFSGT'],
    'bitdefender': ['VSSERV', 'bdredline'],
    'defender': ['WinDefend', 'Sense'],
    'windows defender': ['WinDefend', 'Sense']
  };

  // Trova i servizi da controllare basandosi sul nome dell'antivirus
  const avNameLower = avName.toLowerCase();
  let servicesToCheck: string[] = [];

  for (const [key, services] of Object.entries(serviceMap)) {
    if (avNameLower.includes(key)) {
      servicesToCheck = services;
      break;
    }
  }

  if (servicesToCheck.length === 0) {
    // Se non abbiamo servizi specifici, assumiamo che sia attivo
    // (fallback per antivirus meno comuni)
    console.log(`No known services for ${avName}, assuming it's running`);
    return true;
  }

  // Controlla se almeno uno dei servizi è in esecuzione
  for (const service of servicesToCheck) {
    try {
      const { stdout } = await execAsync(`${scCommand} query "${service}"`);
      if (stdout.includes('RUNNING') || stdout.includes('IN ESECUZIONE')) {
        console.log(`Service ${service} is running for ${avName}`);
        return true;
      }
    } catch {
      // Servizio non trovato o non in esecuzione, prova il prossimo
      continue;
    }
  }

  console.log(`No running services found for ${avName}`);
  return false;
}

export async function detectAntivirus(): Promise<AntivirusStatus> {
  const platform = os.platform();
  const wslDetected = await isWSL();

  try {
    // Se siamo in WSL, rileva antivirus Windows
    if (wslDetected || platform === 'win32') {
      return await detectWindowsAntivirus();
    } else if (platform === 'darwin') {
      return await detectMacAntivirus();
    } else if (platform === 'linux') {
      return await detectLinuxAntivirus();
    }

    return { installed: false, enabled: false, updated: false };
  } catch (error) {
    console.error('Error detecting antivirus:', error);
    return { installed: false, enabled: false, updated: false };
  }
}

async function detectWindowsAntivirus(): Promise<AntivirusStatus> {
  const isWsl = await isWSL();
  const psCommand = isWsl ? 'powershell.exe' : 'powershell';

  // Metodo 1: Rileva TUTTI gli antivirus tramite Windows Security Center
  try {
    const { stdout } = await execAsync(
      `${psCommand} -Command "Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct | Select-Object displayName, productState | ConvertTo-Json"`
    );

    const products = JSON.parse(stdout.trim());
    console.log('Antivirus products found:', products);

    // Se è un singolo prodotto, convertilo in array
    const avList = Array.isArray(products) ? products : [products];

    if (avList.length > 0) {
      // Decodifica del productState di Windows Security Center
      // Documentazione Microsoft:
      // - Bit 12 (0x1000): Security provider health (1 = enabled, 0 = disabled)
      // - Bit 16 (0x10000): Signature status (1 = out of date, 0 = up to date)
      // - Bit 18 (0x40000): Product state (varia)

      const decodeProductState = (state: number) => {
        // Check se l'antivirus è abilitato (bit 12)
        const enabled = (state & 0x1000) !== 0;

        // Check se le definizioni sono aggiornate (bit 16 a 0 = aggiornato)
        const updated = (state & 0x10000) === 0;

        return { enabled, updated };
      };

      // Filtra gli antivirus che sono effettivamente in esecuzione
      const runningAVs: Array<{av: any, enabled: boolean, updated: boolean}> = [];

      for (const av of avList) {
        const { enabled, updated } = decodeProductState(av.productState);
        const isRunning = await isAntivirusRunning(av.displayName);

        if (isRunning) {
          runningAVs.push({ av, enabled, updated });
        } else {
          console.log(`Skipping ${av.displayName} - no running services found`);
        }
      }

      if (runningAVs.length === 0) {
        console.log('No running antivirus found in Security Center');
        // Fallback al metodo Windows Defender
      } else {
        // Prendi il primo antivirus abilitato e in esecuzione
        const selectedAV = runningAVs.find(item => item.enabled) || runningAVs[0];
        const state = selectedAV.av.productState;
        const hex = state.toString(16);

        console.log(`Antivirus selected: ${selectedAV.av.displayName}`);
        console.log(`  State: ${state} (0x${hex})`);
        console.log(`  Enabled: ${selectedAV.enabled}, Updated: ${selectedAV.updated}`);

        return {
          installed: true,
          name: selectedAV.av.displayName,
          enabled: selectedAV.enabled,
          updated: selectedAV.updated
        };
      }
    }
  } catch (error) {
    console.error('Error checking Security Center:', error);
  }

  // Metodo 2 (Fallback): Check specifico per Windows Defender
  try {
    const { stdout } = await execAsync(
      `${psCommand} -Command "Get-MpComputerStatus | Select-Object AntivirusEnabled, RealTimeProtectionEnabled, AntivirusSignatureLastUpdated | ConvertTo-Json"`
    );

    const status = JSON.parse(stdout.trim());
    console.log('Windows Defender status (fallback):', status);

    return {
      installed: true,
      name: 'Windows Defender',
      enabled: status.AntivirusEnabled && status.RealTimeProtectionEnabled,
      updated: true
    };
  } catch (error) {
    console.error('Error checking Windows Defender:', error);
  }

  // Metodo 3 (Ultimo fallback): Controlla servizio WinDefend
  try {
    const scCommand = isWsl ? 'sc.exe' : 'sc';
    await execAsync(`${scCommand} query WinDefend`);
    return {
      installed: true,
      name: 'Windows Defender',
      enabled: true,
      updated: true
    };
  } catch (fallbackError) {
    console.error('All antivirus detection methods failed:', fallbackError);
    return { installed: false, enabled: false, updated: false };
  }
}

async function detectMacAntivirus(): Promise<AntivirusStatus> {
  // macOS non ha un antivirus built-in tradizionale
  // Check per software comuni come Sophos, Avast, etc.
  const commonAV = ['Sophos', 'Avast', 'AVG', 'Norton', 'McAfee'];

  for (const av of commonAV) {
    try {
      await execAsync(`ps aux | grep -i ${av}`);
      return {
        installed: true,
        name: av,
        enabled: true,
        updated: true
      };
    } catch {
      continue;
    }
  }

  return { installed: false, enabled: false, updated: false };
}

async function detectLinuxAntivirus(): Promise<AntivirusStatus> {
  // Check ClamAV
  try {
    await execAsync('which clamscan');

    // Prova a controllare il servizio senza sudo
    try {
      const { stdout } = await execAsync('systemctl is-active clamav-daemon');
      console.log('ClamAV daemon status:', stdout.trim());

      return {
        installed: true,
        name: 'ClamAV',
        enabled: stdout.trim() === 'active',
        updated: true
      };
    } catch {
      // Se non riesce a controllare il servizio, assume installato ma stato sconosciuto
      console.log('ClamAV installed but daemon status unknown');
      return {
        installed: true,
        name: 'ClamAV',
        enabled: false,
        updated: true
      };
    }
  } catch (error) {
    console.log('ClamAV not found:', error);
    return { installed: false, enabled: false, updated: false };
  }
}
